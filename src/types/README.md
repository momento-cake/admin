# Type Definitions Guide

This directory contains all TypeScript type definitions for the Momento Cake Admin application. The types are organized by domain and include comprehensive JSDoc documentation for IDE support.

## Directory Structure

```
/src/types/
├── index.ts              # Core user, client, and invitation types
├── ingredient.ts         # Ingredient, supplier, and inventory types
├── recipe.ts            # Recipe, recipe item, and cost calculation types
├── utils.ts             # Type guards, utilities, and helper functions
└── constants.ts         # Shared type constants (future)
```

## Type Organization

### Core Domain Types

#### User Management (`index.ts`)
- **`UserModel`**: Represents an authenticated user in the system
  - Includes role-based access control (admin/viewer)
  - Stores user metadata and profile information
  - Tracks creation and last sign-in timestamps

- **`UserInvitation`**: Represents a pending user invitation
  - Generated by admins to invite new users
  - Includes expiration tracking
  - Records invitation and acceptance timestamps

- **`UserRegistrationData`**: Form data for user registration
  - Includes password requirements
  - Validates terms acceptance

#### Client Management (`index.ts`)
- **`Client`**: Represents a customer/client
  - Supports both person and business types
  - Stores contact information and addresses
  - Tracks document numbers (CPF/CNPJ) for Brazilian compliance

#### Ingredient Management (`ingredient.ts`)
- **`Ingredient`**: Represents an ingredient in inventory
  - Tracks unit of measurement and quantity
  - Stores pricing and supplier information
  - Maintains minimum and current stock levels
  - Includes allergen tracking

- **`Supplier`**: Represents a supplier/vendor
  - Stores contact information
  - Supports Brazilian address format
  - Includes CNPJ/CPF for business identification
  - Tracks ratings and product categories

- **`UnitConversion`**: Defines conversion between units
  - Maps from one unit to another
  - Stores conversion factor (e.g., 1kg = 1000g)
  - Used in recipe scaling and unit conversion

#### Recipe Management (`recipe.ts`)
- **`Recipe`**: Complete recipe definition
  - Includes ingredients and preparation steps
  - Calculates costs and serving information
  - Tracks recipe category and difficulty
  - Stores denormalized data for performance

- **`RecipeItem`**: Unified ingredient or sub-recipe reference
  - Can reference either ingredients or other recipes
  - Includes quantity, unit, and cost information
  - Supports custom notes per item

- **`RecipeStep`**: Single step in recipe preparation
  - Includes step number, instruction, and time
  - Used to calculate total preparation time

### Form Data Types

Form-specific types extend core domain types with validation constraints:

- **`CreateIngredientData`**: Data for creating a new ingredient
- **`UpdateIngredientData`**: Data for updating an ingredient (partial fields)
- **`CreateRecipeData`**: Data for creating a new recipe
- **`UpdateRecipeData`**: Data for updating a recipe (partial fields)
- **`UserRegistrationData`**: User registration form data

## Type Guards and Utilities

The `utils.ts` file provides runtime type safety through type guards:

### Type Guard Functions

```typescript
import { isIngredient, isRecipe, isUser } from '@/types/utils';

// Safely check if unknown data is an ingredient
if (isIngredient(data)) {
  // TypeScript now knows 'data' is Ingredient type
  console.log(data.name);
}

// Type guard with fallback
const ingredient = safeAssert(data, isIngredient, defaultIngredient);
```

Available type guards:
- `isIngredient()` - Check if object is Ingredient
- `isSupplier()` - Check if object is Supplier
- `isUnitConversion()` - Check if object is UnitConversion
- `isRecipe()` - Check if object is Recipe
- `isRecipeItem()` - Check if object is RecipeItem
- `isRecipeStep()` - Check if object is RecipeStep
- `isCostBreakdown()` - Check if object is CostBreakdown
- `isUser()` - Check if object is UserModel
- `isUserInvitation()` - Check if object is UserInvitation
- `isClient()` - Check if object is Client

### Enum Validators

```typescript
import { getValidIngredientCategories, isStockStatus } from '@/types/utils';

// Get all valid category values
const categories = getValidIngredientCategories();

// Check if value is valid stock status
if (isStockStatus(value)) {
  // Type is now 'StockStatus'
}
```

### Utility Types

```typescript
import { ReadonlyDeep, PartialDeep } from '@/types/utils';

// Make all properties readonly recursively
type ReadonlyRecipe = ReadonlyDeep<Recipe>;

// Make all properties optional recursively
type OptionalRecipe = PartialDeep<Recipe>;
```

## Validation Schemas

Type definitions work in conjunction with Zod validation schemas:

### Validator Files
- `/src/lib/validators/ingredient.ts` - Ingredient validation
- `/src/lib/validators/recipe.ts` - Recipe validation
- `/src/lib/validators/user.ts` - User validation

### Usage Pattern

```typescript
import { recipeValidation, type RecipeFormData } from '@/lib/validators/recipe';

// Form data type inferred from Zod schema
const formData: RecipeFormData = {
  name: 'Pão de Queijo',
  category: 'breads',
  // ... other fields
};

// Parse and validate
try {
  const validated = recipeValidation.parse(formData);
  // validated is guaranteed to be valid RecipeFormData
} catch (error) {
  // Handle validation error
}
```

## Enums

### IngredientUnit
Units of measurement for ingredients:
- `KILOGRAM` - kg
- `GRAM` - g
- `LITER` - l
- `MILLILITER` - ml
- `UNIT` - individual unit (eggs, items, etc.)

### IngredientCategory
Categories for organizing ingredients:
- `FLOUR` - Flour and grain products
- `SUGAR` - Sugar and sweeteners
- `DAIRY` - Milk, cheese, butter, yogurt
- `EGGS` - Eggs and egg products
- `FATS` - Oils, butter, shortening
- `LEAVENING` - Baking powder, yeast
- `FLAVORING` - Vanilla, extracts, essences
- `NUTS` - Nuts and nut products
- `FRUITS` - Fresh and dried fruits
- `CHOCOLATE` - Cocoa and chocolate products
- `SPICES` - Cinnamon, nutmeg, etc.
- `PRESERVATIVES` - Preservatives and additives
- `OTHER` - Other ingredients

### RecipeCategory
Categories for organizing recipes:
- `CAKES` - Cakes and large pastries
- `CUPCAKES` - Individual cupcakes
- `COOKIES` - Cookies and small bites
- `BREADS` - Breads and rolls
- `PASTRIES` - Pastries and croissants
- `ICINGS` - Icings and frostings
- `FILLINGS` - Fillings and creams
- `OTHER` - Other recipes

### RecipeDifficulty
Difficulty levels:
- `EASY` - Minimal technique required
- `MEDIUM` - Some technique and timing
- `HARD` - Advanced techniques required

### UserRole
User roles for access control:
- `admin` - Full system access
- `viewer` - Read-only access

### InvitationStatus
Status of user invitations:
- `pending` - Invitation sent, awaiting acceptance
- `accepted` - User accepted and registered
- `expired` - Invitation expired
- `cancelled` - Invitation cancelled by admin

### StockStatus
Stock level indicators:
- `good` - Stock above minimum threshold
- `low` - Stock below minimum but above critical
- `critical` - Stock very low, immediate reorder needed
- `out` - Out of stock

## Type Safety Best Practices

### 1. Use Type Guards at Boundaries

```typescript
// Good: Validate data at API boundaries
export async function getIngredient(data: unknown): Promise<Ingredient> {
  const ingredient = safeAssert(data, isIngredient, null);
  if (!ingredient) {
    throw new Error('Invalid ingredient data');
  }
  return ingredient;
}
```

### 2. Leverage Discriminated Unions

```typescript
// Discriminated union for form state
type FormState =
  | { status: 'idle' }
  | { status: 'loading' }
  | { status: 'success'; data: Recipe }
  | { status: 'error'; error: string };

// Type-safe pattern matching
function handleFormState(state: FormState) {
  switch (state.status) {
    case 'idle':
      // state has no data
      break;
    case 'success':
      // state.data is guaranteed to be Recipe
      console.log(state.data.name);
      break;
  }
}
```

### 3. Use Readonly for Immutable Data

```typescript
import { ReadonlyDeep } from '@/types/utils';

// Enforce immutability
function displayRecipe(recipe: ReadonlyDeep<Recipe>) {
  // recipe.name = 'New Name'; // Error: property is readonly
  console.log(recipe.name);
}
```

### 4. Document Constraints in JSDoc

```typescript
/**
 * Creates a new ingredient with validation.
 *
 * @remarks
 * - Ingredient name must be 2-100 characters
 * - Stock must be greater than zero
 * - At least one allergen should be specified for safety
 *
 * @throws {ValidationError} If ingredient data is invalid
 */
export async function createIngredient(
  data: CreateIngredientData
): Promise<Ingredient> {
  // implementation
}
```

## Common Patterns

### Pattern 1: Creating Form Data

```typescript
import { type CreateRecipeData } from '@/types/recipe';

const newRecipe: CreateRecipeData = {
  name: 'Bolo de Chocolate',
  category: 'cakes',
  generatedAmount: 900,
  generatedUnit: 'gram',
  servings: 8,
  difficulty: 'medium',
  recipeItems: [
    {
      type: 'ingredient',
      ingredientId: 'ing_001',
      quantity: 200,
      unit: 'gram',
    },
  ],
  instructions: [
    {
      stepNumber: 1,
      instruction: 'Mix dry ingredients',
      timeMinutes: 5,
    },
  ],
};
```

### Pattern 2: Type-Safe API Calls

```typescript
import { type RecipesResponse } from '@/types/recipe';

async function fetchRecipes(): Promise<RecipesResponse> {
  const response = await fetch('/api/recipes');
  const data: unknown = await response.json();

  if (!Array.isArray(data.recipes)) {
    throw new Error('Invalid response format');
  }

  return data as RecipesResponse;
}
```

### Pattern 3: Conditional Rendering

```typescript
import { isRecipe, isIngredient } from '@/types/utils';

function renderItem(item: unknown) {
  if (isRecipe(item)) {
    return <RecipeDisplay recipe={item} />;
  }
  if (isIngredient(item)) {
    return <IngredientDisplay ingredient={item} />;
  }
  return <UnknownItemDisplay />;
}
```

## Migration Guide

### From Legacy Types

If migrating from older type definitions:

1. **Replace inline prop types** with types from this directory
2. **Use validators** for form data validation
3. **Add type guards** for runtime type checking
4. **Use enums** instead of string literals

### Example Migration

Before:
```typescript
interface Props {
  ingredient: any;
  category: 'flour' | 'sugar' | 'dairy'; // ❌ String literals
}
```

After:
```typescript
import { type Ingredient, IngredientCategory } from '@/types/ingredient';

interface Props {
  ingredient: Ingredient; // ✅ Proper type
  category: IngredientCategory; // ✅ Enum
}
```

## Related Documentation

- **Validators**: `/src/lib/validators/README.md` (if it exists)
- **Component Types**: `/src/components/[feature]/types.ts`
- **API Types**: `Todo - to be created`
- **TypeScript Config**: `/tsconfig.json`

## Contributing

When adding new types:

1. Add comprehensive JSDoc comments
2. Create corresponding Zod validation schema
3. Add type guard function in `utils.ts`
4. Export types in appropriate `index.ts`
5. Add usage examples in this README

## Debugging Type Issues

### Issue: "Type '...' is not assignable to type '...'"

Check:
1. Field names match exactly (case-sensitive)
2. All required fields are present
3. Use type guards to validate at runtime

### Issue: "Property '...' does not exist on type '...'"

Check:
1. Spelling of property name
2. The property is not optional (`?`) if you're accessing it
3. Use proper type narrowing before access

### Issue: Type inference showing `any`

Improve:
1. Add explicit type annotations
2. Use type guards for runtime validation
3. Import types from proper locations

## Resources

- [TypeScript Handbook](https://www.typescriptlang.org/docs/)
- [Type Guards](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates)
- [JSDoc Reference](https://jsdoc.app/)
- [Zod Documentation](https://zod.dev/)
